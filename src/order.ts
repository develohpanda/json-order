/* eslint-disable @typescript-eslint/ban-types */

import clonedeep from 'lodash.clonedeep';
import {PropertyMap} from './models';

interface GetResult {
  exists: boolean;
  value: object;
}

const splitKey = (key: string, separator: string): Array<string> => {
  const parts: Array<string> = [];
  let currentPart = '';
  let isLiteral = false;

  for (let index = 0; index < key.length; index++) {
    const character = key[index];

    if (isLiteral) {
      currentPart += character;
      isLiteral = false;
    } else if (character === '\\') {
      isLiteral = true;
    } else if (
      character === separator[0] &&
      key.substr(index, separator.length) === separator
    ) {
      parts.push(currentPart);
      currentPart = '';
      index += separator.length - 1;
    } else {
      currentPart += character;
    }
  }

  parts.push(currentPart);

  return parts;
};

const getProperty = (
  obj: object,
  key: string,
  separator: string
): GetResult => {
  let exists = true;

  const value = splitKey(key, separator)
    .slice(1)
    .reduce((o: object, x: string) => {
      exists = o && o.hasOwnProperty(x);

      if (!exists) {
        return undefined;
      }

      return o[x];
    }, obj);

  return {exists, value};
};

const setProperty = (
  obj: object,
  key: string,
  value: object,
  separator: string
) => {
  splitKey(key, separator)
    .slice(1)
    .reduce((o: object, x: string, idx: number, src: Array<string>): object => {
      if (idx === src.length - 1) {
        const valueToSet = Array.isArray(value)
          ? clonedeep(value).map((p) => (typeof p === 'object' ? {} : p))
          : value;
        o[x] = valueToSet;
      }

      return o[x];
    }, obj);
};

const copyProperty = (
  sourceObject: object,
  resultObject: object,
  propertyPath: string,
  separator: string
) => {
  const result = getProperty(sourceObject, propertyPath, separator);
  if (result.exists) {
    setProperty(resultObject, propertyPath, result.value, separator);
  }
};

/**
 * Duplicate a JS object but containing a particular property order
 *
 * @param sourceObject an object with the properties in any order
 * @param map the `PropertyMap` generated by the `parse` method
 * @param separator a non-empty `string` that controls what the key separator is in the generated map. Defaults to `~`.
 * @returns the source object ordered as per the map
 */
const order = <T extends object>(
  sourceObject: T,
  map: PropertyMap | null,
  separator = '~'
): T => {
  if (separator.length < 1) {
    throw new Error('Separator should not be an empty string.');
  } else if (separator === '/') {
    throw new Error('Separator cannot be "/".');
  }

  if (!map) {
    return sourceObject;
  }

  const mapKeys = Object.keys(map);
  const prefixLength = (mapKeys[0] && mapKeys[0].length) || 0;

  const resultObject = {};
  mapKeys.forEach((mk) => {
    const childKeys = map[mk];

    // Remove prefix
    const parentKey = mk.substr(prefixLength);

    const parent = getProperty(sourceObject, parentKey, separator);

    if (parent.exists) {
      // Set a default value for the property
      const defaultValue = Array.isArray(parent.value) ? parent.value : {};

      setProperty(resultObject, parentKey, defaultValue, separator);

      // Fetch value from source and set on output
      childKeys.forEach((key) =>
        copyProperty(
          sourceObject,
          resultObject,
          `${parentKey}${separator}${key}`,
          separator
        )
      );
    }
  });

  return resultObject as T;
};

export default order;
